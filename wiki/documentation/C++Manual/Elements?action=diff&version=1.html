
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title> Elements - libRocket</title>
<link rel="start" href="http://librocket.com/wiki"/><link rel="search" href="http://librocket.com/search"/><link rel="help" href="../../TracGuide.html"/><link rel="stylesheet" href="../../../chrome/common/css/trac.css" type="text/css"/><link rel="stylesheet" href="../../../chrome/common/css/wiki.css" type="text/css"/><link rel="stylesheet" href="../../../chrome/common/css/diff.css" type="text/css"/><link rel="icon" href="../../../chrome/site/trac.ico" type="image/x-icon"/><link rel="shortcut icon" href="../../../chrome/site/trac.ico" type="image/x-icon"/><link rel="next" href="Elements%3Faction=diff&amp;version=2.html" title="Version 2"/><style type="text/css">
</style>
<script type="text/javascript" src="../../../chrome/common/js/trac.js"></script>
<link rel="stylesheet" type="text/css" href="../../../chrome/site/style/base.css"></link>
<link rel="stylesheet" type="text/css" href="../../../chrome/site/style/content.css"></link>
<link rel="stylesheet" type="text/css" href="../../../chrome/site/style/discussion.css"></link>
<style>
		div.wiki img
		{
			display: block;
			margin-left: auto;
			margin-right: auto;
		}
	</style>
</head>
<body>
<div class="widthshell-width">
<div class="widthshell-minwidth">
<div class="widthshell-layout">
<div class="widthshell-container">
<div class="widthshell-content">
<div id="background">
<div style="float:right;width:160px;height:600px;margin-top:110px;margin-right:20px;">
<script type="text/javascript"><!--
                        google_ad_client = "pub-5872045433470541";
                        /* Default, Wide Skyscraper */
                        google_ad_slot = "3956485030";
                        google_ad_width = 160;
                        google_ad_height = 600;
                //-->
                </script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
                </script>
</div>
<div class="shell">
<div class="stars">
<img id="star-1" src="../../../chrome/site/images/star-red-medium.gif" width="22px" height="22px" alt="Star"/>
<img id="star-2" src="../../../chrome/site/images/star-red-small.gif" width="13px" height="13px" alt="Star"/>
<img id="star-3" src="../../../chrome/site/images/star-red-small.gif" width="11px" height="11px" alt="Star"/>
<img id="star-4" src="../../../chrome/site/images/star-orange-small.gif" width="16px" height="16px" alt="Star"/>
<img id="star-5" src="../../../chrome/site/images/star-red-tiny.gif" width="7px" height="6px" alt="Star"/>
<img id="star-6" src="../../../chrome/site/images/star-red-tiny.gif" width="8px" height="7px" alt="Star"/>
<img id="star-7" src="../../../chrome/site/images/star-red-tiny.gif" width="7px" height="6px" alt="Star"/>
<img id="star-8" src="../../../chrome/site/images/star-red-big.gif" width="33px" height="33px" alt="Star"/>
<img id="star-9" src="../../../chrome/site/images/star-red-small.gif" width="13px" height="13px" alt="Star"/>
<img id="star-10" src="../../../chrome/site/images/star-red-tiny.gif" width="7px" height="6px" alt="Star"/>
<img id="star-11" src="../../../chrome/site/images/star-red-tiny.gif" width="8px" height="7px" alt="Star"/>
<img id="star-12" src="../../../chrome/site/images/star-red-tiny.gif" width="7px" height="6px" alt="Star"/>
</div>
<div id="header">
<a href="../../documentation.html"><img id="title" src="../../../chrome/site/images/title.gif" width="256px" height="49px" alt="Rocket"/></a>
<ul class="top-level-nav">
<li><a href="../../frontend/features.html">features.</a></li>

<li><a href="http://github.com/lloydw/librocket">download.</a></li>
<li><a href="http://forums.librocket.com">forums.</a></li>
<li><a href="../../documentation.html">developer.</a></li>
</ul>
<img id="trail" src="../../../chrome/site/images/trail-content.gif" width="72px" height="115px" alt="Rocket Trail"/>
<a href="../../documentation.html"><img id="rocket" src="../../../chrome/site/images/rocket-content.gif" width="126px" height="139px" alt="Rocket"/></a>
</div>
</div>
</div>
<div class="shell">
<div id="banner">
<div class="stars">
<img id="star-13" src="../../../chrome/site/images/star-black-big.gif" width="49px" height="50px" alt="Star"/>
<img id="star-14" src="../../../chrome/site/images/star-black-medium.gif" width="23px" height="23px" alt="Star"/>
<img id="star-15" src="../../../chrome/site/images/star-black-small.gif" width="14px" height="14px" alt="Star"/>
<img id="star-16" src="../../../chrome/site/images/star-black-small.gif" width="14px" height="14px" alt="Star"/>
<img id="star-17" src="../../../chrome/site/images/star-black-medium.gif" width="21px" height="21px" alt="Star"/>
<img id="star-18" src="../../../chrome/site/images/star-black-tiny.gif" width="13px" height="13px" alt="Star"/>
<img id="star-19" src="../../../chrome/site/images/star-black-tiny.gif" width="9px" height="9px" alt="Star"/>
<img id="star-20" src="../../../chrome/site/images/star-black-tiny.gif" width="10px" height="10px" alt="Star"/>
<img id="star-21" src="../../../chrome/site/images/star-black-medium.gif" width="21px" height="21px" alt="Star"/>
<img id="star-22" src="../../../chrome/site/images/star-black-small.gif" width="14px" height="14px" alt="Star"/>
<img id="star-23" src="../../../chrome/site/images/star-black-small.gif" width="13px" height="13px" alt="Star"/>
</div>
<img id="banner-bottom-left" src="../../../chrome/site/images/banner-bottom-left.gif" width="20px" height="19px" alt="Bottom left banner image"/>
<img id="banner-bottom-right" src="../../../chrome/site/images/banner-bottom-right.gif" width="20px" height="19px" alt="Bottom right banner image"/>
<div id="login"><a href="http://librocket.com/login">Login</a> | <a "http://librocket.com/wiki/documentation/C%2B%2BManual/href">Register</a></div>
<div id="breadcrumbs">
<a href="../../documentation.html">documentation</a> <strong>&#8249;</strong> <a href="http://librocket.com/wiki/documentation/C++Manual">C++Manual</a> <strong>&#8249;</strong> <a href="http://librocket.com/wiki/documentation/C++Manual/Elements">Elements</a></div>
<div id="title"> Elements</div>
<div id="second-level-nav">
<span class="nav-item active"><a href="../../documentation.html">Documentation</a></span>
<span class="nav-item"><a accesskey="4" href="http://librocket.com/search">Search</a></span>
</div>
</div>
<div id="content-container">
<div id="content" class="wiki">
<h1>Changes from
<a href="Elements%3Fversion=1.html">Version 1</a> of
<a href="Elements.html">documentation/C++Manual/Elements</a></h1>
<form method="post" id="prefs" action="Elements.html"><div><input type="hidden" name="__FORM_TOKEN" value="a669ff33c84a83d396ad829a"/></div>
<div>
<input type="hidden" name="action" value="diff"/>
<input type="hidden" name="version" value="1"/>
<input type="hidden" name="old_version" value/>
<label>View differences <select name="style">
<option value="inline" selected="selected">inline</option>
<option value="sidebyside">side by side</option>
</select></label>
<div class="field">
Show <input type="text" name="contextlines" id="contextlines" size="2" maxlength="3" value="2"/>
<label for="contextlines">lines around each change</label>
</div>
<fieldset id="ignore">
<legend>Ignore:</legend>
<div class="field">
<input type="checkbox" id="blanklines" name="ignoreblanklines"/>
<label for="blanklines">Blank lines</label>
</div>
<div class="field">
<input type="checkbox" id="case" name="ignorecase"/>
<label for="case">Case changes</label>
</div>
<div class="field">
<input type="checkbox" id="whitespace" name="ignorewhitespace"/>
<label for="whitespace">White space changes</label>
</div>
</fieldset>
<div class="buttons">
<input type="submit" name="update" value="Update"/>
</div>
</div>
</form>
<dl id="overview">
<dt class="property author">Author:</dt>
<dd class="author">peterc <span class="ipnr">(IP: 192.168.0.1)</span></dd>
<dt class="property time">Timestamp:</dt>
<dd class="time">12/20/07 12:16:34 (10 years ago)</dd>
<dt class="property message">Comment:</dt>
<dd class="message"><p>
--
</p>
</dd>
</dl>
<div class="diff">
<div id="legend">
<h3>Legend:</h3>
<dl>
<dt class="unmod"></dt><dd>Unmodified</dd>
<dt class="add"></dt><dd>Added</dd>
<dt class="rem"></dt><dd>Removed</dd>
<dt class="mod"></dt><dd>Modified</dd>
</dl>
</div>
<ul class="entries">
<li class="entry">
<h2>documentation/C++Manual/Elements</h2>
<table class="inline" summary="Differences">
<colgroup><col class="lineno"/><col class="lineno"/><col class="content"/></colgroup>
<thead><tr>
<th title="Version ">v0</th>
<th title="Version 1">v1</th>
<th>&nbsp;</th>
</tr></thead><tbody class="add"><tr class="first"><th>&nbsp;</th><th>1</th><td class="r"><ins>[[PageOutline(1-5, Contents)]]</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>2</th><td class="r"><ins>= Elements =</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>3</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>4</th><td class="r"><ins>An element is the smallest subdivision of functionality within a document.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>5</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>6</th><td class="r"><ins>== Size ==</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>7</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>8</th><td class="r"><ins>Elements are made up of zero or more boxes, each of which has a rectangular content area surrounded by three areas of varying thicknesses; padding, borders and margin (see the [wiki:documentation/RCSS/BoxModel box model documentation] for more details).</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>9</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>10</th><td class="r"><ins>You can query the current size of an element with the GetBox() and GetNumBoxes() functions:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>11</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>12</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>13</th><td class="r"><ins>// Returns one of the boxes describing the size of the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>14</th><td class="r"><ins>// @param[in] index The index of the desired box.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>15</th><td class="r"><ins>/ @return The requested box.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>16</th><td class="r"><ins>const Rocket::Core::Box&amp; GetBox(int index = 0) const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>17</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>18</th><td class="r"><ins>// Returns the number of boxes making up this element's geometry.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>19</th><td class="r"><ins>// @return the number of boxes making up this element's geometry.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>20</th><td class="r"><ins>int GetNumBoxes() const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>21</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>22</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>23</th><td class="r"><ins>Most elements will have one box, except if they represent inline content split over multiple lines.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>24</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>25</th><td class="r"><ins>== Position ==</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>26</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>27</th><td class="r"><ins>Elements measure their position as a pixel offset from a containing ancestor element. The containing element, referred to as the ''offset parent'', is generally the element's closest ancestor with a 'position' value other than 'static'. To get an element's offset parent, call the GetOffsetParent() function.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>28</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>29</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>30</th><td class="r"><ins>// Returns the element from which all offset calculations are currently computed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>31</th><td class="r"><ins>// @return This element's offset parent.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>32</th><td class="r"><ins>Rocket::Core::Element* GetOffsetParent();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>33</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>34</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>35</th><td class="r"><ins>To retrieve the element's offset, use GetRelativeOffset() or GetAbsoluteOffset():</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>36</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>37</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>38</th><td class="r"><ins>// Returns the position of the top-left corner of one of the areas of this element's primary box, relative to its</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>39</th><td class="r"><ins>// offset parent's top-left border corner.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>40</th><td class="r"><ins>// @param[in] area The desired area position.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>41</th><td class="r"><ins>// @return The relative offset.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>42</th><td class="r"><ins>EMP::Core::Vector2f GetRelativeOffset(Rocket::Core::Box::Area area = Box::CONTENT) const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>43</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>44</th><td class="r"><ins>// Returns the position of the top-left corner of one of the areas of this element's primary box, relative to</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>45</th><td class="r"><ins>// the element root.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>46</th><td class="r"><ins>// @param[in] area The desired area position.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>47</th><td class="r"><ins>// @return The absolute offset.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>48</th><td class="r"><ins>EMP::Core::Vector2f GetAbsoluteOffset(Rocket::Core::Box::Area area = Box::CONTENT) const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>49</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>50</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>51</th><td class="r"><ins>GetRelativeOffset() will return the offset from the element's offset parent's top-left border to one of the areas of the element's primary box. GetAbsoluteOffset() will return the offset from the top-left corner of the context the element is part of.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>52</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>53</th><td class="r"><ins>You can also use the [wiki:documentation/C++Manual/Elements#DOMinterface DOM functions] GetClientLeft() and GetClientTop().</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>54</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>55</th><td class="r"><ins>== Pseudo-classes ==</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>56</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>57</th><td class="r"><ins>Elements may have one or more ''pseudo-classes'' active on them at any one time. Pseudo-classes represent minor, temporary changes of state (such as input focus or mouse hovering) that can be used to change the value of RCSS properties.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>58</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>59</th><td class="r"><ins>To check if a pseudo-class is set on a particular element, you can use either the IsPseudoClassSet() or GetActivePseudoClasses() function.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>60</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>61</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>62</th><td class="r"><ins>// Checks if a specific pseudo-class has been set on the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>63</th><td class="r"><ins>// @param[in] pseudo_class The name of the pseudo-class to check for.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>64</th><td class="r"><ins>// @return True if the pseudo-class is set on the element, false if not.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>65</th><td class="r"><ins>bool IsPseudoClassSet(const EMP::Core::String&amp; pseudo_class) const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>66</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>67</th><td class="r"><ins>// Gets a list of the current active pseudo-classes.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>68</th><td class="r"><ins>// @return The list of active pseudo-classes.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>69</th><td class="r"><ins>const Rocket::Core::PseudoClassList&amp; GetActivePseudoClasses() const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>70</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>71</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>72</th><td class="r"><ins>IsPseudoClassSet() will check for the prescence of a particular pseudo-class on the element, while GetActivePseudoClasses() will return an STL set containing all pseudo-classes.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>73</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>74</th><td class="r"><ins>To set or remove a pseudo-class, call SetPseudoClass().</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>75</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>76</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>77</th><td class="r"><ins>// Sets or removes a pseudo-class on the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>78</th><td class="r"><ins>// @param[in] pseudo_class The pseudo class to activate or deactivate.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>79</th><td class="r"><ins>// @param[in] activate True if the pseudo-class is to be activated, false to be deactivated.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>80</th><td class="r"><ins>void SetPseudoClass(const EMP::Core::String&amp; pseudo_class, bool activate);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>81</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>82</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>83</th><td class="r"><ins>Applications can make use of any pseudo-classes they wish for their own styling needs. However, Rocket maintains several pseudo-classes internally and it is not recommended you set or clear them yourself. These classes are:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>84</th><td class="r"><ins>&nbsp;* ''hover'': Set when the mouse cursor is positioned over the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>85</th><td class="r"><ins>&nbsp;* ''active'': Set when the primary mouse button is depressed, and was positioned over the element when it was pressed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>86</th><td class="r"><ins>&nbsp;* ''focus'': Set if an element has input focus. Usually this occurs when the element is clicked on.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>87</th><td class="r"><ins>&nbsp;* ''disabled'': Set on a disabled form control.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>88</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>89</th><td class="r"><ins>== DOM interface ==</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>90</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>91</th><td class="r"><ins>Rocket elements support the majority of [http://developer.mozilla.org/en/docs/DOM:element Gecko's HTML DOM element interface], so web developers should be familiar with most of an element's functionality.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>92</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>93</th><td class="r"><ins>|| '''Rocket functions''' || '''Brief description''' || '''Equivalent DOM property''' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>94</th><td class="r"><ins>|| ''GetAbsoluteLeft()'' || The distance from the context's left edge and the element's left border. || ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>95</th><td class="r"><ins>|| ''GetAbsoluteTop()'' || The distance from the context's top edge and the element's top border. || ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>96</th><td class="r"><ins>|| ''SetAttribute()'', ''GetAttribute()'' || All attributes associated with an element. || ''attributes'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>97</th><td class="r"><ins>|| ''GetChild()'', ''GetNumChildren()'' || All child nodes of an element. || ''childNodes'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>98</th><td class="r"><ins>|| ''IsClassSet()'', ''SetClass()'' || Gets/sets the class of the element. || ''className'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>99</th><td class="r"><ins>|| ''GetClientHeight()'' || The inner height of an element. || ''clientHeight'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>100</th><td class="r"><ins>|| ''GetClientLeft()'' || The width of the left border of an element. || ''clientLeft'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>101</th><td class="r"><ins>|| ''GetClientTop()'' || The width of the top border of an element. || ''clientTop'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>102</th><td class="r"><ins>|| ''GetClientWidth()'' || The inner width of an element. || ''clientWidth'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>103</th><td class="r"><ins>|| ''GetFirstChild()'' || The first direct child node of an element. || ''firstChild'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>104</th><td class="r"><ins>|| ''GetID()'', ''SetID()'' || Gets/sets the id of the element. || ''id'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>105</th><td class="r"><ins>|| ''GetInnerRML()'', ''SetInnerRML()'' || Gets/sets the markup and content of the element. || ''innerHTML'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>106</th><td class="r"><ins>|| ''GetLastChild()'' || The last direct child node of an element. || ''lastChild'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>107</th><td class="r"><ins>|| ''GetNextSibling()'' || The node immediately following the given one in the tree. || ''nextSibling'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>108</th><td class="r"><ins>|| ''GetOffsetHeight()'' || The height of an element, relative to the layout. || ''offsetHeight'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>109</th><td class="r"><ins>|| ''GetOffsetLeft()'' || The distance from this element's left border to its offset parent's left border. || ''offsetLeft'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>110</th><td class="r"><ins>|| ''GetOffsetParent()'' || The element from which all offset calculations are currently computed. || ''offsetParent'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>111</th><td class="r"><ins>|| ''GetOffsetTop()'' || The distance from this element's top border to its offset parent's top border. || ''offsetTop'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>112</th><td class="r"><ins>|| ''GetOffsetWidth()'' || The width of an element, relative to the layout. || ''offsetWidth'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>113</th><td class="r"><ins>|| ''GetOwnerDocument()'' || The document that this node is in. || ''ownerDocument'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>114</th><td class="r"><ins>|| ''GetParentNode()'' || The parent element of this node. || ''parentNode'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>115</th><td class="r"><ins>|| ''GetPreviousSibling()'' || The node immediately preceding the given one in the tree. || ''previousSibling'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>116</th><td class="r"><ins>|| ''GetScrollHeight()'' || The scroll view height of an element. || ''scrollHeight'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>117</th><td class="r"><ins>|| ''GetScrollLeft()'' || Gets/sets the left scroll offset of an element. || ''scrollLeft'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>118</th><td class="r"><ins>|| ''GetScrollTop()'' || Gets/sets the top scroll offset of an element. || ''scrollTop'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>119</th><td class="r"><ins>|| ''GetScrollWidth()'' || The scroll view width of an element. || ''scrollWidth'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>120</th><td class="r"><ins>|| ''GetProperty()'', ''SetProperty()'' || An object representing the declarations of an element's style attributes. || ''style'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>121</th><td class="r"><ins>|| ''GetTagName()'' || The name of the tag for the given element. || ''tagName'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>122</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>123</th><td class="r"><ins>Supported methods have simply had their initial letter capitalised to match the rest of the Rocket API.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>124</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>125</th><td class="r"><ins>|| '''Rocket function''' || '''Brief description''' || '''Equivalent DOM method''' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>126</th><td class="r"><ins>|| ''AddEventListener()'' || Register an event handler to a specific event type on the element. || ''addEventListener()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>127</th><td class="r"><ins>|| ''AppendChild()'' || Insert a node as the last child node of this element. || ''appendChild()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>128</th><td class="r"><ins>|| ''Blur()'' || Removes keyboard focus from the current element. || ''blur()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>129</th><td class="r"><ins>|| ''Click()'' || Simulates a click on the current element. || ''click()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>130</th><td class="r"><ins>|| ''DispatchEvent()'' || Dispatch an event to this node in the DOM. || ''dispatchEvent()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>131</th><td class="r"><ins>|| ''Focus()'' || Gives keyboard focus to the current element. || ''focus()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>132</th><td class="r"><ins>|| ''GetAttribute()'' || Retrieve the value of the named attribute from the current node. || ''getAttribute()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>133</th><td class="r"><ins>|| ''GetElementById()'' || Returns an object reference to the identified element. || ''getElementById()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>134</th><td class="r"><ins>|| ''GetElementsByTagName()'' || Retrieve a set of all descendant elements, of a particular tag name, from the current element. || ''getElementsByTagName()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>135</th><td class="r"><ins>|| ''HasAttribute()'' || Check if the element has the specified attribute, or not. || ''hasAttribute()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>136</th><td class="r"><ins>|| ''HasChildNodes()'' || Check if the element has any child nodes, or not. || ''hasChildNodes()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>137</th><td class="r"><ins>|| ''InsertBefore()'' || Inserts the first node before the second, child, node in the DOM. || ''insertBefore()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>138</th><td class="r"><ins>|| ''RemoveAttribute()'' || Remove the named attribute from the current node. || ''removeAttribute()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>139</th><td class="r"><ins>|| ''RemoveChild()'' || Removes a child node from the current element. || ''removeChild()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>140</th><td class="r"><ins>|| ''RemoveEventListener()'' || Removes an event listener from the element. || ''removeEventListener()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>141</th><td class="r"><ins>|| ''ReplaceChild()'' || Replaces one child node in the current element with another. || ''replaceChild()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>142</th><td class="r"><ins>|| ''ScrollIntoView()'' || Scrolls the page until the element gets into the view. || ''scrollIntoView()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>143</th><td class="r"><ins>|| ''SetAttribute()'' || Set the value of the named attribute from the current node. || ''setAttribute()'' ||</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>144</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>145</th><td class="r"><ins>== Dynamically creating elements ==</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>146</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>147</th><td class="r"><ins>Elements should not be created with the 'new' operator; in order to be properly reference counted and released, in C++ they need to be created either through a document (using the CreateElement() or CreateTextNode() function) or through the Rocket factory (Rocket::Core::Factory) using the factory's static InstanceElement() function.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>148</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>149</th><td class="r"><ins>=== Using the factory ===</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>150</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>151</th><td class="r"><ins>Creating an element through the factory allows more control. The InstanceElement() function is detailed below:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>152</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>153</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>154</th><td class="r"><ins>// Instances a single element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>155</th><td class="r"><ins>// @param[in] parent The parent of the new element, or NULL for a root tag.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>156</th><td class="r"><ins>// @param[in] instancer The name of the instancer to create the element with.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>157</th><td class="r"><ins>// @param[in] tag The tag of the element to be instanced.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>158</th><td class="r"><ins>// @param[in] attributes The attributes to instance the element with.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>159</th><td class="r"><ins>// @return The instanced element, or NULL if the instancing failed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>160</th><td class="r"><ins>static Rocket::Core::Element* InstanceElement(Rocket::Core::Element* parent,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>161</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const EMP::Core::String&amp; instancer,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>162</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const EMP::Core::String&amp; tag,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>163</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const EMP::Core::XMLAttributes&amp; attributes);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>164</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>165</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>166</th><td class="r"><ins>The function's parameters are:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>167</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>168</th><td class="r"><ins>&nbsp;* ''parent'': The element you intend to parent the element to once it has been created. This is only used by custom instancers; if you're instancing a generic element you can leave this out. Note that the new element will not be automatically parented to this element, you still need to do that yourself once the element has been created.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>169</th><td class="r"><ins>&nbsp;* ''instancer'': The tag name the instancer you want to create the element was registered against. For creating generic elements, this can be the same as the third parameter, 'tag'. For more information, see the section on [wiki:documentation/C++Manual/Elements#Registeringaninstancer custom element instancers].</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>170</th><td class="r"><ins>&nbsp;* ''tag'': The tag the new element should have.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>171</th><td class="r"><ins>&nbsp;* ''attributes'': Any attributes you want the new element to be constructed with. This is a dictionary type. The attributes will be passed into the instancer and set on the element if instancing was successful.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>172</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>173</th><td class="r"><ins>For example, the following will instance a 'div' element:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>174</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>175</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>176</th><td class="r"><ins>Rocket::Core::Element* div_element = Rocket::Core::Factory::InstanceElement(NULL,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>177</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "div",</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>178</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "div",</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>179</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EMP::Core::XMLAttributes());</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>180</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>181</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>182</th><td class="r"><ins>The following will instance a radio button element using the Controls plugin input instancer, but gives it a tag of 'radio':</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>183</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>184</th><td class="r"><ins>EMP::Core::XMLAttributes attributes;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>185</th><td class="r"><ins>attributes.Set("type", "radio");</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>186</th><td class="r"><ins>attributes.Set("name", "graphics");</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>187</th><td class="r"><ins>attributes.Set("value", "OK");</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>188</th><td class="r"><ins>Rocket::Core::Element* radio_element = Rocket::Core::Factory::InstanceElement(div_element,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>189</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "input",</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>190</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "radio",</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>191</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributes);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>192</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>193</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>194</th><td class="r"><ins>If the element is instanced successfully, it will be returned. If not, NULL (0) will be returned. All elements are reference counted, and the newly instanced element will be returned with one initial reference owned by the instancing code; be sure to remove it once you have parented the element to another.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>195</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>196</th><td class="r"><ins>=== Using a document ===</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>197</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>198</th><td class="r"><ins>To create an element through a document use one of the following functions:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>199</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>200</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>201</th><td class="r"><ins>// Creates the named element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>202</th><td class="r"><ins>// @param[in] name The tag name of the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>203</th><td class="r"><ins>Rocket::Core::Element* CreateElement(const EMP::Core::String&amp; name);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>204</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>205</th><td class="r"><ins>// Create a text element with the given text content.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>206</th><td class="r"><ins>// @param[in] text The text content of the text element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>207</th><td class="r"><ins>Rocket::Core::ElementText* CreateTextNode(const EMP::Core::String&amp; text);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>208</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>209</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>210</th><td class="r"><ins>CreateElement() takes a single parameter, ''name'', the tag name of the new element. This will be used to both look up the instancer and tag the element. Like instancing the element through the factory, the new element will be returned if it was created successfully, or NULL if not.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>211</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>212</th><td class="r"><ins>CreateTextNode() creates a single text element containing the text given in the parameter ''text''.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>213</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>214</th><td class="r"><ins>Note that elements returned by these functions are not affiliated with the document itself. The new element will have an initial reference count of one owned by the constructing code, so remember to remove the reference once the element has been attached to another element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>215</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>216</th><td class="r"><ins>The following example adds a paragraph element with a text node under it to a document:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>217</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>218</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>219</th><td class="r"><ins>bool AddSampleText(Rocket::Core::Document* document)</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>220</th><td class="r"><ins>{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>221</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; Rocket::Core::Element* new_element = document-&gt;CreateElement("p");</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>222</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; if (new_element == NULL)</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>223</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>224</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>225</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; Rocket::Core::TextElement* new_text_element = document-&gt;CreateTextNode("Sample text.");</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>226</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; if (new_text_element == NULL)</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>227</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; {</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>228</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_element-&gt;RemoveReference();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>229</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>230</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; }</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>231</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>232</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; new_element-&gt;AppendChild(new_text_element);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>233</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; document-&gt;AddChild(new_element);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>234</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; return true;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>235</th><td class="r"><ins>}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>236</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>237</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>238</th><td class="r"><ins>== Destroying elements ==</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>239</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>240</th><td class="r"><ins>Elements are reference-counted objects, so are not meant to be deleted directly. If an element is part of a hierarchy, simply remove it from its parent to destroy it with the RemoveChild() function. If it is a loose element, remove the initial reference on the object with the RemoveReference() function.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>241</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>242</th><td class="r"><ins>== Custom elements ==</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>243</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>244</th><td class="r"><ins>If you need special functionality on an element that you can't easily manage through the event system, you have the option of creating a custom element. Custom elements derive directly from the core Element class definition and are created through a custom element instancer. Custom elements can:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>245</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>246</th><td class="r"><ins>&nbsp;* Respond to property and attribute changes.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>247</th><td class="r"><ins>&nbsp;* Manage the layout of hidden internal elements.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>248</th><td class="r"><ins>&nbsp;* Execute custom update or rendering code.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>249</th><td class="r"><ins>&nbsp;* Respond to events inline.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>250</th><td class="r"><ins>&nbsp;* Respond to descendant add / remove events.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>251</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>252</th><td class="r"><ins>=== Creating a custom element ===</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>253</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>254</th><td class="r"><ins>All custom elements are classes derived (not necessarily directly) from Rocket::Core::Element. The constructor for Element takes one parameter, the tag of the element; a derived element's constructor can either pass a constant string down to the base constructor, or take a string themselves to pass down.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>255</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>256</th><td class="r"><ins>The virtual functions that can be overridden in a custom element are:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>257</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>258</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>259</th><td class="r"><ins>// Returns the baseline of the element, in pixels offset from the bottom of the element's content area.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>260</th><td class="r"><ins>// @return The element's baseline. A negative baseline will be further 'up' the element, a positive on further 'down'.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>261</th><td class="r"><ins>virtual float GetBaseline() const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>262</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>263</th><td class="r"><ins>// Gets the intrinsic dimensions of this element, if it is of a type that has an inherent size.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>264</th><td class="r"><ins>// @param[in] dimensions The dimensions to size, if appropriate.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>265</th><td class="r"><ins>// @return True if the element has intrinsic dimensions, false otherwise.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>266</th><td class="r"><ins>virtual bool GetIntrinsicDimensions(EMP::Core::Vector2f&amp; dimensions);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>267</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>268</th><td class="r"><ins>// Called for every event sent to this element or one of its descendants.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>269</th><td class="r"><ins>// @param[in] event The event to process.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>270</th><td class="r"><ins>virtual void ProcessEvent(Rocket::Core::Event&amp; event);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>271</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>272</th><td class="r"><ins>// Called during the update loop after children are updated.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>273</th><td class="r"><ins>virtual void OnUpdate();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>274</th><td class="r"><ins>// Called during render after backgrounds, borders, decorators, but before children, are rendered.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>275</th><td class="r"><ins>virtual void OnRender();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>276</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>277</th><td class="r"><ins>// Called when attributes on the element are changed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>278</th><td class="r"><ins>// @param[in] changed_attributes The attributes changed on the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>279</th><td class="r"><ins>virtual void OnAttributeChange(const Rocket::Core::AttributeNameList&amp; changed_attributes);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>280</th><td class="r"><ins>// Called when properties on the element are changed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>281</th><td class="r"><ins>// @param[in] changed_properties The properties changed on the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>282</th><td class="r"><ins>virtual void OnPropertyChange(const Rocket::Core::PropertyNameList&amp; changed_properties);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>283</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>284</th><td class="r"><ins>// Called when a child node has been added somewhere in the hierarchy.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>285</th><td class="r"><ins>// @param[in] child The element that has been added. This may be this element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>286</th><td class="r"><ins>virtual void OnChildAdd(Rocket::Core::Element* child);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>287</th><td class="r"><ins>// Called when a child node has been removed somewhere in the hierarchy.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>288</th><td class="r"><ins>// @param[in] child The element that has been removed. This may be this element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>289</th><td class="r"><ins>virtual void OnChildRemove(Rocket::Core::Element* child);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>290</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>291</th><td class="r"><ins>// Gets the markup and content of the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>292</th><td class="r"><ins>// @param[out] content The content of the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>293</th><td class="r"><ins>virtual void GetInnerRML(EMP::Core::String&amp; content) const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>294</th><td class="r"><ins>// Returns the RML of this element and all children.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>295</th><td class="r"><ins>// @param[out] content The content of this element and those under it, in XML form.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>296</th><td class="r"><ins>virtual void GetRML(EMP::Core::String&amp; content);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>297</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>298</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>299</th><td class="r"><ins>==== Layout ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>300</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>301</th><td class="r"><ins>A custom element can override the GetIntrinsicDimensions() function if it wants to be laid out as a ''replaced element''. Replaced elements are elements with intrinsic dimensions that can be positioned like inline or block content. Examples of replaced elements are images and form controls.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>302</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>303</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>304</th><td class="r"><ins>// Gets the intrinsic dimensions of this element, if it is of a type that has an inherent size.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>305</th><td class="r"><ins>// @param[in] dimensions The dimensions to size, if appropriate.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>306</th><td class="r"><ins>// @return True if the element has intrinsic dimensions, false otherwise.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>307</th><td class="r"><ins>virtual bool GetIntrinsicDimensions(EMP::Core::Vector2f&amp; dimensions);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>308</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>309</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>310</th><td class="r"><ins>If a custom element is to be a replaced element, it should override this function and return true. The actual intrinsic dimensions of the element should be put into the ''dimensions'' parameter. This function will be called every time the element is laid out, so the dimension can be a dynamic value. The default element returns false.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>311</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>312</th><td class="r"><ins>A custom replaced element (ie, one with intrinsic dimensions) can override the GetBaseline() function if it wants to change its reference point for horizontal positioning on a line.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>313</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>314</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>315</th><td class="r"><ins>// Returns the baseline of the element, in pixels offset from the bottom of the element's content area.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>316</th><td class="r"><ins>// @return The element's baseline. A negative baseline will be further 'up' the element, a positive on further 'down'.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>317</th><td class="r"><ins>virtual float GetBaseline() const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>318</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>319</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>320</th><td class="r"><ins>The GetBaseline() function returns the pixel offset from the bottom of the element's content area that neighbouring text should, by default, line their baselines up with. This will only affect the element's positioning if it is placed inline.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>321</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>322</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>323</th><td class="r"><ins>==== Event processing ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>324</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>325</th><td class="r"><ins>A custom element can override the ProcessEvent() function to intercept all events sent to this element, or one of its descendants. The element receives the event between the bubble and capture phases.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>326</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>327</th><td class="r"><ins>Note that the element receives ''every'' event, and it is not necessary the target element! Be sure to check the target element of the event and the event type.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>328</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>329</th><td class="r"><ins>'''Important:''' You must remember to call the base class's ProcessEvent() function with any unprocessed events! The base element responds to many events in its ProcessEvent() function, and all manner of strange behaviour may result if you don't do this.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>330</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>331</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>332</th><td class="r"><ins>// Called for every event sent to this element or one of its descendants.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>333</th><td class="r"><ins>// @param[in] event The event to process.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>334</th><td class="r"><ins>virtual void ProcessEvent(Rocket::Core::Event&amp; event);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>335</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>336</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>337</th><td class="r"><ins>==== Hooks into update and render loops ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>338</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>339</th><td class="r"><ins>A custom element can override the OnUpdate() or OnRender() functions to hook functionality into the update or render loops.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>340</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>341</th><td class="r"><ins>The OnUpdate() function is called from the base element's update loop after the element's children have been updated. Child elements will therefore have their OnUpdate() functions call before their parents. There is no need to call the base element's OnUpdate() function if you do not wish to.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>342</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>343</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>344</th><td class="r"><ins>// Called during the update loop after children are updated.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>345</th><td class="r"><ins>virtual void OnUpdate();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>346</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>347</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>348</th><td class="r"><ins>The OnRender() function is called from the base element's render loop after the following has occurred:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>349</th><td class="r"><ins>&nbsp;* Descendant elements in the element's stacking context with a z-index of lower than 0 have been rendered.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>350</th><td class="r"><ins>&nbsp;* The clipping region has been set for the element (if appropriate).</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>351</th><td class="r"><ins>&nbsp;* The elements background, border and all appropriate decorators have been rendered.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>352</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>353</th><td class="r"><ins>There is no need to call the base element's OnRender() function is you do not wish to. Note that most custom rendering can be accomplished through the use of [wiki:documentation/C++Manual/Decorators custom decorators]; this is recommended rather than overriding OnRender() for reusability.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>354</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>355</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>356</th><td class="r"><ins>// Called during render after backgrounds, borders, decorators, but before children, are rendered.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>357</th><td class="r"><ins>virtual void OnRender();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>358</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>359</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>360</th><td class="r"><ins>==== Changes to properties or attributes ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>361</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>362</th><td class="r"><ins>A custom element can override the OnAttributeChange() or OnPropertyChange() functions to respond to changes to its attributes or properties.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>363</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>364</th><td class="r"><ins>OnAttributeChange() is called whenever an attribute is added, removed or redefined. The names of the changed attributes are passed into the function in the 'changed_attributes' variable, which is an STL set of strings. To check if a specific attribute has been altered, look for its presence in the list with the find() function.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>365</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>366</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>367</th><td class="r"><ins>// Called when attributes on the element are changed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>368</th><td class="r"><ins>// @param[in] changed_attributes The attributes changed on the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>369</th><td class="r"><ins>virtual void OnAttributeChange(const Rocket::Core::AttributeNameList&amp; changed_attributes);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>370</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>371</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>372</th><td class="r"><ins>OnPropertyChange() is called whenever the value of a property (or group of properties) is changed. The names of the changed properties are passed into the function in the 'changed_properties' variable, which (like for OnAttributeChange()) is an STL set of strings.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>373</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>374</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>375</th><td class="r"><ins>// Called when properties on the element are changed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>376</th><td class="r"><ins>// @param[in] changed_properties The properties changed on the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>377</th><td class="r"><ins>virtual void OnPropertyChange(const Rocket::Core::PropertyNameList&amp; changed_properties);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>378</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>379</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>380</th><td class="r"><ins>'''Important:''' If you override either of these functions, you must remember to call the base class's corresponding function! As with ProcessEvent(), the base element responds to many attribute and property changes, and all manner of strange behaviour may result if you don't do this.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>381</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>382</th><td class="r"><ins>==== Hierarchy changes ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>383</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>384</th><td class="r"><ins>A custom element can override the OnChildAdd() or OnChildRemove() functions to respond to changes in the element's hierarchy. When an element is added or removed from another, the appropriate function is called on it immediately. The base implementation then passes the call onto its parent, thereby informing the whole hierarchy. If you want to prevent messages from propagating up the element hierarchy, you can choose to not call the base element's OnChildAdd() or OnChildRemove() function as appropriate.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>385</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>386</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>387</th><td class="r"><ins>// Called when a child node has been added somewhere in the hierarchy.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>388</th><td class="r"><ins>// @param[in] child The element that has been added. This may be this element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>389</th><td class="r"><ins>virtual void OnChildAdd(Rocket::Core::Element* child);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>390</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>391</th><td class="r"><ins>// Called when a child node has been removed somewhere in the hierarchy.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>392</th><td class="r"><ins>// @param[in] child The element that has been removed. This may be this element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>393</th><td class="r"><ins>virtual void OnChildRemove(Rocket::Core::Element* child);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>394</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>395</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>396</th><td class="r"><ins>==== RML generation ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>397</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>398</th><td class="r"><ins>A custom element can override the GetRML() and GetInnerRML() function if the default RML generation functions are inadequate. This is generally not needed, unless an element rearranges its child elements internally, or makes heavy use of custom XML node handlers; in this case, the default functions may generate nonsensical RML.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>399</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>400</th><td class="r"><ins>GetInnerRML() is meant to return the ''internal'' RML of the element; ie, only the RML needed to generate the element's content, not the element itself. By default, it calls GetRML() on all of its DOM children and concatenates the result.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>401</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>402</th><td class="r"><ins>GetRML() is meant to return the RML required to generate the entire element. This therefore includes the element's tag and all of its attributes as well as all of its descendant's RML. By default, it generates its open tag, appends to that the the result of GetInnerRML(), and finally appends its closing tag.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>403</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>404</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>405</th><td class="r"><ins>// Gets the markup and content of the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>406</th><td class="r"><ins>// @param[out] content The content of the element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>407</th><td class="r"><ins>virtual void GetInnerRML(EMP::Core::String&amp; content) const;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>408</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>409</th><td class="r"><ins>// Returns the RML of this element and all children.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>410</th><td class="r"><ins>// @param[out] content The content of this element and those under it, in XML form.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>411</th><td class="r"><ins>virtual void GetRML(EMP::Core::String&amp; content);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>412</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>413</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>414</th><td class="r"><ins>=== Creating a custom element instancer ===</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>415</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>416</th><td class="r"><ins>In order to have a custom element created through the Rocket factory, an instancer for the element needs to be registered with the factory against the appropriate RML tag names. An element instancer is responsible for creating and destroying its elements when required, and also destroying itself when Rocket is shut down.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>417</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>418</th><td class="r"><ins>A custom element instancer needs to be derived from Rocket::Core::ElementInstancer, and implement the required pure virtual methods:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>419</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>420</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>421</th><td class="r"><ins>// Instances an element given the tag name and attributes.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>422</th><td class="r"><ins>// @param[in] parent The element the new element is destined to be parented to.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>423</th><td class="r"><ins>// @param[in] tag The tag of the element to instance.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>424</th><td class="r"><ins>// @param[in] attributes Dictionary of attributes.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>425</th><td class="r"><ins>virtual Rocket:Core::Element* InstanceElement(Rocket::Core::Element* parent,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>426</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const EMP::Core::String&amp; tag,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>427</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const EMP::Core::XMLAttributes&amp; attributes) = 0;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>428</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>429</th><td class="r"><ins>// Releases an element instanced by this instancer.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>430</th><td class="r"><ins>// @param[in] element The element to release.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>431</th><td class="r"><ins>virtual void ReleaseElement(Rocket::Core::Element* element) = 0;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>432</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>433</th><td class="r"><ins>// Release the instancer.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>434</th><td class="r"><ins>virtual void Release() = 0;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>435</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>436</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>437</th><td class="r"><ins>InstanceElement() will be called whenever the factory is called upon to instance an element with a tag that the instancer was registered against. The parameters to the function are:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>438</th><td class="r"><ins>&nbsp;* ''parent'': The element that the new element will be parented to if it is created successfully; you do not need to actually do the parenting! This will only be non-NULL if the element is instanced from RML.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>439</th><td class="r"><ins>&nbsp;* ''tag'': The string that whoever is creating the element wants the element's tag to be; due to the way elements are constructed through the factory, this may not be one of the tags the instancer was registered against. It is recommended you pass this through to the element to be its tag name, but this is not required.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>440</th><td class="r"><ins>&nbsp;* ''attributes'': The attributes defined on the element's tag in RML or passed into the factory. You do not need to set these attributes on the element yourself; that will be done automatically if the instancing is successful. You only need to use these if element instancing is dependent on the values (for example, the instancer for 'input' elements instances different types depending on the value of the 'type' attribute).</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>441</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>442</th><td class="r"><ins>If InstanceElement() is successful, return the new element. Otherwise, return NULL (0) to indicate an instancing error.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>443</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>444</th><td class="r"><ins>ReleaseElement() will be called when an element instanced through the instancer is no longer required by the system. It should be deleted appropriately.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>445</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>446</th><td class="r"><ins>Release() will be called when the element instancer is no longer required, usually when Rocket is shut down. The instancer should delete itself as appropriate.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>447</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>448</th><td class="r"><ins>==== Registering an instancer ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>449</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>450</th><td class="r"><ins>To register a custom instancer with Rocket, call the RegisterElementInstancer() function on the Rocket factory (Rocket::Core::Factory) after Rocket has been initialised.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>451</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>452</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>453</th><td class="r"><ins>Rocket::Core::ElementInstancer* custom_instancer = new ElementInstancerCustom();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>454</th><td class="r"><ins>Rocket::Core::Factory::RegisterElementInstancer("custom", custom_instancer);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>455</th><td class="r"><ins>custom_instancer-&gt;RemoveReference();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>456</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>457</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>458</th><td class="r"><ins>The first parameter to RegisterElementInstancer() is the tag name the instancer is bound to. In the above example, the custom instancer will be called to instance an element whenever an element with the tag 'custom' is encountered while parsing an RML stream, or as otherwise required by the factory. You can register an instancer as many times as you like with the factory against different tag names.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>459</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>460</th><td class="r"><ins>Instancers are reference counted, and begin with a reference count of one which belongs to the constructing process. The factory itself will add a reference for every tag name it is bound to. Therefore, remember to remove a reference from the object after it has been registered with the factory. If you don't, it will never be released.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>461</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>462</th><td class="r"><ins>==== Using a generic instancer ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>463</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>464</th><td class="r"><ins>If a custom element does not require any special behaviour from its instancer, the easiest way to generate an instancer for it is to use the templated ElementInstancerGeneric. Instead of deriving your own instancer class, simply construct a new Rocket::Core::ElementInstancerGeneric templated to the type of the custom element you'd like to instance, and register it with the factory as you would a normal instancer.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>465</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>466</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>467</th><td class="r"><ins>Rocket::Core::ElementInstancer* custom_instancer = new Rocket::Core::ElementInstancerGeneric&lt; CustomElement &gt;();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>468</th><td class="r"><ins>Rocket::Core::Factory::RegisterElementInstancer("custom", custom_instancer);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>469</th><td class="r"><ins>custom_instancer-&gt;RemoveReference();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>470</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>471</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>472</th><td class="r"><ins>The only requirement on the element type that it is templated to is that the constructor take a string (the tag name) like the base element.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>473</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>474</th><td class="r"><ins>=== Custom XML node handling ===</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>475</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>476</th><td class="r"><ins>For some complex custom elements, the RML required to generate the element is not indicative of the actual internal hierarchy. For example, in the [wiki:documentation/C++Manual/Controls Controls plugin], columns in a data grid element are specified by &lt;col&gt; tags immediately beneath the &lt;datagrid&gt; tag. If the standard XML parsing was being executed, an element would be instanced and parented to the data grid for each column tag - but this isn't what is wanted. So a custom XML node handler is used for data grids that processes the column tag differently.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>477</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>478</th><td class="r"><ins>Node handlers are registered against RML tag names. When an RML file is being parsed, the XML parser maintains a stack of node handlers. Whenever a new tag is encountered, the parser checks if a specific node handler is registered against that tag; if so, that handler is pushed onto the stack and takes over the parsing until its associated tag is closed. If no handler is associated with a particular element, the current node handler continues parsing.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>479</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>480</th><td class="r"><ins>==== Creating a custom XML node handler ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>481</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>482</th><td class="r"><ins>Custom node handlers derive from the Rocket::Core::XMLNodeHandler class and implement the pure virtual functions:</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>483</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>484</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>485</th><td class="r"><ins>// Called when a new element tag is opened.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>486</th><td class="r"><ins>// @param parser The parser executing the parse.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>487</th><td class="r"><ins>// @param name The XML tag name.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>488</th><td class="r"><ins>// @param attributes The tag attributes.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>489</th><td class="r"><ins>// @return The new element, may be NULL if no element was created.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>490</th><td class="r"><ins>virtual Rocket::Core::Element* ElementStart(Rocket::Core::XMLParser* parser,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>491</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const EMP::Core::String&amp; name,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>492</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const EMP::Core::XMLAttributes&amp; attributes) = 0;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>493</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>494</th><td class="r"><ins>// Called when an element is closed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>495</th><td class="r"><ins>// @param parser The parser executing the parse.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>496</th><td class="r"><ins>// @param name The XML tag name.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>497</th><td class="r"><ins>virtual bool ElementEnd(Rocket::Core::XMLParser* parser,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>498</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const EMP::Core::String&amp; name) = 0;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>499</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>500</th><td class="r"><ins>// Called for element data.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>501</th><td class="r"><ins>// @param parser The parser executing the parse.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>502</th><td class="r"><ins>// @param data The element data.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>503</th><td class="r"><ins>virtual bool ElementData(Rocket::Core::XMLParser* parser,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>504</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const EMP::Core::String&amp; data) = 0;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>505</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>506</th><td class="r"><ins>// Called to release the node handler.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>507</th><td class="r"><ins>virtual void Release() = 0;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>508</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>509</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>510</th><td class="r"><ins>Release() is called when Rocket is shut down; the node handler should delete itself as appropriate.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>511</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>512</th><td class="r"><ins>ElementStart(), ElementEnd() and ElementData() are called on the node handler for the appropriate XML parse events that occur while it is the active node handler. A self-closing tag will result in a call to ElementEnd() immediately after ElementStart(). ElementData() is called when loose non-whitespace data is encountered between two tags.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>513</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>514</th><td class="r"><ins>Each of these functions is passed a pointer to the XML parser running the parse. From the parser the current ''parse frame'' can be requested with the GetParseFrame() function; the parse frame object contains the current element and tag being processed, as well as the active node handler.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>515</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>516</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>517</th><td class="r"><ins>struct ParseFrame</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>518</th><td class="r"><ins>{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>519</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; // Tag being parsed.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>520</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; EMP::Core::String tag;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>521</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>522</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; // Element representing this frame.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>523</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; Rocket::Core::Element* element;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>524</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>525</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; // Handler used for this frame.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>526</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; XMLNodeHandler* node_handler;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>527</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>528</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; // The default handler used for this frame's children.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>529</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; XMLNodeHandler* child_handler;</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>530</th><td class="r"><ins>};</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>531</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>532</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>533</th><td class="r"><ins>ElementStart() is called with the name and attributes of the opening tag. If the node handler creates a new element and wants it on the top parse frame, it should return the element. Otherwise, it should return NULL to keep the current element on top of the parse frame stack. This is useful if the node handler creates internal elements for the current element, but doesn't want any further parsing executed on them.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>534</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>535</th><td class="r"><ins>If the node handler wants to change the node handler for the new element, it can push a new handler onto the XML parser's stack using PushHandler() or PushDefaultHandler() from ElementStart(). The default handler will instance elements as described previously in the documentation.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>536</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>537</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>538</th><td class="r"><ins>// Pushes an element handler onto the parse stack for parsing child elements.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>539</th><td class="r"><ins>// @param[in] tag The tag the handler was registered with.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>540</th><td class="r"><ins>// @return True if an appropriate handler was found and pushed onto the stack, false if not.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>541</th><td class="r"><ins>bool PushHandler(const EMP::Core::String&amp; tag);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>542</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>543</th><td class="r"><ins>// Pushes the default element handler onto the parse stack.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>544</th><td class="r"><ins>void PushDefaultHandler();</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>545</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>546</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>547</th><td class="r"><ins>If it doesn't call either of these methods, it will remain the node handler for any child elements it creates.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>548</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>549</th><td class="r"><ins>==== Registering a custom node handler ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>550</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>551</th><td class="r"><ins>Register a custom node handler with Rocket's XML parser with the static RegisterNodeHandler() function on Rocket::Core::XMLParser. You can register the same handler multiple times with the parser against different tag names. RegisterNodeHandler() adds a reference to the node handler, so be sure to remove the initial reference from the handler once it has been registered.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>552</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>553</th><td class="r"><ins>{{{</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>554</th><td class="r"><ins>// Registers a custom node handler to be used to a given tag.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>555</th><td class="r"><ins>// @param[in] tag The tag the custom parser will handle.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>556</th><td class="r"><ins>// @param[in] handler The custom handler.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>557</th><td class="r"><ins>// @return The registered XML node handler.</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>558</th><td class="r"><ins>static Rocket::Core::XMLNodeHandler* RegisterNodeHandler(const EMP::Core::String&amp; tag,</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>559</th><td class="r"><ins>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rocket::Core::XMLNodeHandler* handler);</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>560</th><td class="r"><ins>}}}</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>561</th><td class="r"><ins></ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>562</th><td class="r"><ins>==== Samples ====</ins>&nbsp;</td></tr><tr><th>&nbsp;</th><th>563</th><td class="r"><ins></ins>&nbsp;</td></tr><tr class="last"><th>&nbsp;</th><th>564</th><td class="r"><ins>Custom XML node handlers are used extensively in the Controls plugin; consult the source for the XMLNodeHandlerDataGrid, XMLNodeHandlerTabSet and XMLNodeHandlerTextArea classes for demonstrations of their use.</ins>&nbsp;</td></tr></tbody>
</table>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<a id="tracpowered" href="http://trac.edgewall.org/">
<img src="../../../chrome/common/trac_logo_mini.png" height="30" width="107" alt="Trac Powered"/>
</a>
<p class="left">
Powered by <a href="http://librocket.com/about"><strong>Trac </strong></a><br/>By <a href="http://www.edgewall.org/">Edgewall Software</a>.
</p>
<p id="copyright" class="left clear">
Copyright &copy; 2007-2010 Code Point Ltd, Shift Technology Ltd.
</p>
<ul class="top-level-nav">
<li><a href="../../frontend/features.html">features.</a></li>
<li><a "http://librocket.com/wiki/documentation/C%2B%2BManual/href">download.</a></li>
<li><a href="http://forums.librocket.com">forums.</a></li>
<li><a href="../../documentation.html">developer.</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
<script type="text/javascript">
    var pageTracker = _gat._getTracker("UA-3379591-1");
    pageTracker._initData();
    pageTracker._trackPageview();
    </script>
</body>
</html>
